using Il2Cpp_Modding_Codegen.Config;
using Il2Cpp_Modding_Codegen.Data;
using Il2Cpp_Modding_Codegen.Serialization.Interfaces;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace Il2Cpp_Modding_Codegen.Serialization
{
    public class CppTypeDataSerializer : ISerializer<ITypeData>
    {
        private string _prefix;
        private bool _asHeader;

        private string _typeName;
        private string _parentName;
        private string _qualifiedName;
        private CppFieldSerializer fieldSerializer;
        private CppMethodSerializer methodSerializer;
        private SerializationConfig _config;

        public CppTypeDataSerializer(SerializationConfig config, string prefix = "", bool asHeader = true)
        {
            _config = config;
            _prefix = prefix;
            _asHeader = asHeader;
        }

        public void PreSerialize(ISerializerContext context, ITypeData type)
        {
            _qualifiedName = context.QualifiedTypeName;
            if (_asHeader)
            {
                _typeName = context.GetNameFromReference(type.This, ForceAsType.Literal, false, false);
                if (type.Parent != null)
                    _parentName = context.GetNameFromReference(type.Parent, ForceAsType.Literal, genericParams: true);
                // TODO: Make prefix configurable
                fieldSerializer = new CppFieldSerializer(_prefix + "  ");
                foreach (var f in type.Fields)
                    fieldSerializer.PreSerialize(context, f);
            }
            if (type.Type != TypeEnum.Interface)
                methodSerializer = new CppMethodSerializer(_config, _asHeader ? _prefix + "  " : _prefix, _asHeader);
            else
                // TODO: Add a specific interface method serializer here, or provide more state to the original method serializer to support it
                methodSerializer = null;

            foreach (var m in type.Methods)
                methodSerializer?.PreSerialize(context, m);
        }

        // Should be provided a file, with all references resolved:
        // That means that everything is either forward declared or included (with included files "to be built")
        // This is the responsibility of our parent serializer, who is responsible for converting the context into that
        public void Serialize(Stream stream, ITypeData type)
        {
            // Don't use a using statement here because it will close the underlying stream-- we want to keep it open
            var writer = new StreamWriter(stream);
            if (_asHeader)
            {
                var fieldStream = new MemoryStream();
                if (type.Type != TypeEnum.Interface)
                {
                    // Write fields if not an interface
                    foreach (var f in type.Fields)
                    {
                        try
                        {
                            fieldSerializer.Serialize(fieldStream, f);
                        }
                        catch (UnresolvedTypeException e)
                        {
                            if (_config.UnresolvedTypeExceptionHandling.FieldHandling == UnresolvedTypeExceptionHandling.DisplayInFile)
                            {
                                var fs = new StreamWriter(fieldStream);
                                fs.WriteLine("/*");
                                fs.WriteLine(e);
                                fs.WriteLine("*/");
                                fs.Flush();
                            }
                            else if (_config.UnresolvedTypeExceptionHandling.FieldHandling == UnresolvedTypeExceptionHandling.Elevate)
                                throw;
                        }
                    }
                }
                var specifiers = "";
                foreach (var spec in type.Specifiers)
                    specifiers += spec + " ";
                writer.WriteLine($"{_prefix}// Autogenerated type: {specifiers + type.This}");
                if (type.ImplementingInterfaces.Count > 0)
                {
                    writer.Write($"{_prefix}// Implementing Interfaces: ");
                    for (int i = 0; i < type.ImplementingInterfaces.Count; i++)
                    {
                        writer.Write(type.ImplementingInterfaces[i]);
                        if (i != type.ImplementingInterfaces.Count - 1)
                            writer.Write(", ");
                    }
                    writer.WriteLine();
                }
                string s = "";
                if (_parentName != null)
                    s = $" : {_parentName}";
                // TODO: add implementing interfaces to s
                if (type.This.Generic)
                {
                    var templateStr = "template<";
                    bool first = true;
                    foreach (var genParam in type.This.GenericParameters)
                    {
                        if (!first) templateStr += ", ";
                        templateStr += "typename " + genParam.Name;
                        first = false;
                    }
                    writer.WriteLine(_prefix + templateStr + ">");
                }

                // TODO: print enums as actual C++ smart enums? backing type is type of _value and A = #, should work for the lines inside the enum
                var typeHeader = type.Type == TypeEnum.Struct ? "struct " : "class " + _typeName + s;
                writer.WriteLine(_prefix + typeHeader + " {");
                writer.Flush();
                if (type.Type != TypeEnum.Interface)
                {
                    fieldStream.WriteTo(writer.BaseStream);
                    writer.Flush();
                }
                // After the typedef is closed, we write the methods
            }
            foreach (var m in type.Methods)
            {
                try
                {
                    methodSerializer?.Serialize(writer.BaseStream, m);
                }
                catch (UnresolvedTypeException e)
                {
                    if (_config.UnresolvedTypeExceptionHandling.MethodHandling == UnresolvedTypeExceptionHandling.DisplayInFile)
                    {
                        writer.WriteLine("/*");
                        writer.WriteLine(e);
                        writer.WriteLine("*/");
                        writer.Flush();
                    }
                    else if (_config.UnresolvedTypeExceptionHandling.MethodHandling == UnresolvedTypeExceptionHandling.Elevate)
                        throw;
                }
            }
            // Write type closing "};"
            // if the type is generic, write the DEFINE_IL2CPP_ARG_TYPE within the typedef
            if (type.This.Generic && type.Type == TypeEnum.Struct || type.Type == TypeEnum.Enum)
            {
                writer.WriteLine(_prefix + "  " + $"DEFINE_IL2CPP_ARG_TYPE({_qualifiedName}, \"{type.This.Namespace}\", \"{type.This.Name}\");");
            }
            if (_asHeader)
                writer.WriteLine(_prefix + "}" + (type.This.Generic ? "" : " " + _typeName) + ";");
            writer.Flush();
        }
    }
}