using Il2Cpp_Modding_Codegen.Data;
using Il2Cpp_Modding_Codegen.Serialization.Interfaces;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace Il2Cpp_Modding_Codegen.Serialization
{
    public class CppMethodSerializer : ISerializer<IMethod>
    {
        private string _prefix;
        private bool _asHeader;

        private Dictionary<IMethod, string> _resolvedTypeNames = new Dictionary<IMethod, string>();
        private Dictionary<IMethod, string> _declaringTypeNames = new Dictionary<IMethod, string>();
        private Dictionary<IMethod, List<string>> _parameterMaps = new Dictionary<IMethod, List<string>>();
        private string _declaringFullyQualified;

        public CppMethodSerializer(string prefix = "", bool asHeader = true)
        {
            _prefix = prefix;
            _asHeader = asHeader;
        }

        public void PreSerialize(ISerializerContext context, IMethod method)
        {
            // Get the fully qualified name of the context
            _declaringFullyQualified = context.QualifiedTypeName;
            // We need to forward declare/include all types that are either returned from the method or are parameters
            _resolvedTypeNames.Add(method, context.GetNameFromReference(method.ReturnType));
            // The declaringTypeName needs to be a reference, even if the type itself is a value type.
            _declaringTypeNames.Add(method, context.GetNameFromReference(method.DeclaringType, ForceAsType.Pointer));
            var parameterMap = new List<string>();
            foreach (var p in method.Parameters)
            {
                string s;
                if (p.Flags != ParameterFlags.None)
                    s = context.GetNameFromReference(p.Type, ForceAsType.Reference);
                else
                    s = context.GetNameFromReference(p.Type);
                parameterMap.Add(s);
            }
            _parameterMaps.Add(method, parameterMap);
        }

        private string WriteMethod(bool staticFunc, IMethod method, bool namespaceQualified)
        {
            // If the method is an instance method, first parameter should be a pointer to the declaringType.
            string paramString = "";
            if (!staticFunc)
            {
                paramString = $"{_declaringTypeNames[method]} self";
                if (method.Parameters.Count > 0)
                {
                    paramString += ", ";
                }
            }
            var ns = "";
            if (namespaceQualified)
                ns = _declaringFullyQualified + "::";
            return $"{_prefix}{_resolvedTypeNames[method]} {ns}{method.Name}({paramString + method.Parameters.FormatParameters(_parameterMaps[method], FormatParameterMode.Names | FormatParameterMode.Types)})";
        }

        // Write the method here
        public void Serialize(Stream stream, IMethod method)
        {
            if (_resolvedTypeNames[method] == null)
                throw new UnresolvedTypeException(method.DeclaringType, method.ReturnType);
            if (_declaringTypeNames[method] == null)
                throw new UnresolvedTypeException(method.DeclaringType, method.DeclaringType);
            var val = _parameterMaps[method].FindIndex(s => s == null);
            if (val != -1)
                throw new UnresolvedTypeException(method.DeclaringType, method.Parameters[val].Type);
            // Don't use a using statement here because it will close the underlying stream-- we want to keep it open
            var writer = new StreamWriter(stream);

            if (_asHeader)
            {
                var methodString = "";
                bool staticFunc = false;
                foreach (var spec in method.Specifiers)
                {
                    methodString += $"{spec} ";
                    if (spec.Static)
                    {
                        staticFunc = true;
                    }
                }
                methodString += $"{method.ReturnType} {method.Name}({method.Parameters.FormatParameters()})";
                methodString += $" // Offset: 0x{method.Offset:X}";
                writer.WriteLine($"{_prefix}// {methodString}");
                if (method.ImplementedFrom != null)
                    writer.WriteLine($"{_prefix}// Implemented from: {method.ImplementedFrom}");
                writer.WriteLine($"{WriteMethod(staticFunc, method, false)};");
            }
            else
            {
                writer.WriteLine($"{_prefix}// Autogenerated method: {method.DeclaringType}.{method.Name}");
                bool isStatic = method.Specifiers.IsStatic();
                writer.WriteLine(WriteMethod(isStatic, method, true));
                writer.WriteLine(_prefix + "{");
                string restorePrefix = _prefix;
                // TODO: Prefix by configurable amount?
                _prefix += "  ";
                var s = "";
                if (method.ReturnType != TypeDefinition.VoidType)
                {
                    s = "return ";
                }
                s += $"CRASH_UNLESS(il2cpp_utils::RunMethod<{_resolvedTypeNames[method]}>(";
                if (!isStatic)
                {
                    s += "self, ";
                }
                else
                {
                    s += $"\"{method.DeclaringType.Namespace}\", \"{method.DeclaringType.Name}\", ";
                }
                var paramString = method.Parameters.FormatParameters(_parameterMaps[method], FormatParameterMode.Names);
                if (!string.IsNullOrEmpty(paramString))
                    paramString = ", " + paramString;
                s += $"\"{method.Name}\"{paramString}));";
                // Write method with return
                writer.WriteLine($"{_prefix}{s}");
                // Close method
                _prefix = restorePrefix;
                writer.WriteLine(_prefix + "}");
            }
            writer.Flush();
        }
    }
}